# Evaluates the target function using parallelMap
# @param wrapFun [\code{function}] \cr
#   A function which evaluates one item of xs and returns a list with the \code{y}, \code{time} and \code{user.extras}
# @param xs [\code{list}] \cr
#   A list of the x values to evaluate by \code{wrapFun}
# @param xs.schedule.info [\code{list}] \cr
#   A list containing vectors of the same length as \code{xs} giving the estimated times, priorities and times.se for each evaluation of \code{x}.
# @param opt.state [\code{OptState}]\cr
# @return [\code{list}] \cr
#   List containing the results of \code{wrapFun} for each item in xs


evalScheduleKnapsack = function(wrapFun, xs, xs.trafo, xs.schedule.info = NULL, extras = NULL, opt.state) {
	if (!is.null(xs.schedule.info$times)) {
		control = getOptProblemControl(getOptStateOptProblem(opt.state))
		schedule.nodes = control$schedule.nodes
		
		# order everything according to times in xs.schedule.info
		order.idx = order(xs.schedule.info$times, decreasing = FALSE)
		xs = xs[order.idx]
		xs.trafo = xs.trafo[order.idx]
		xs.schedule.info = xs.schedule.info[order.idx,, drop = FALSE]
		extras = extras[order.idx]
		#delete Rows without full scheduling information
		del.na = complete.cases(xs.schedule.info)
		xs.schedule.info = xs.schedule.info[del.na,]
		xs = xs[del.na]
		xs.trafo = xs.trafo[del.na]
		extras = extras[del.na]
		
		
		# initialize Variables
		occupied.time = double(length = schedule.nodes)
		scheduled = data.frame(
		  job = integer(), #which job got scheduled
		  on = integer(), #on which node is it scheduled
		  at = double() #at what time is is scheduled
		)
		pos.max.prio = which.max(xs.schedule.info$priorities)
		t.max = xs.schedule.info$times[pos.max.prio] * 1.05
		x.times =  xs.schedule.info$times[xs.schedule.info$times <= t.max]
    
		neg.time = which(x.times < 0)
		if (length(neg.time) > 0){
		  x.times[neg.time] = max (x.times[neg.time] + xs.schedule.info$times.se[neg.time], min(x.times[x.times>0]))
		  t.max = max(t.max , x.times)
		}
		
		# if more than one job is available for scheduling use knapsack
		# else schedule it direct
		if (length(x.times) >= 2){
		  no.jobs = length(x.times)						
		  no.nodes = schedule.nodes
		  # no negative priorities
		  min.prio = min(xs.schedule.info$priorities[1:no.jobs])
		  if (min.prio < 0){
		    x.prios = xs.schedule.info$priorities[1:no.jobs] - min.prio * 1.01
		  }else{
		    x.prios =  xs.schedule.info$priorities[1:no.jobs] 
		  }
		  #
		  # convert variables for Knapsack(integer)
		  max.time = rep(t.max, times=no.nodes) 
		  if(typeof(x.prios) != "integer"){
		  	tmp = round(.Machine$integer.max / (1000 * sum(x.prios)))
		  	x.prios = as.integer(x.prios * tmp)
		  }
		  ks.prio = x.prios
		  ks.time = as.integer(x.times * 1000)
		  ks.cap = as.integer(max.time * 1000)
		  if (requireNamespace("adagio")){
		    ks.vector = adagio::mknapsack(ks.prio, ks.time, ks.cap, bck = 10000)
		  }else{
		    stop("Package adagio is needed for Knapsack scheduling. Please install it", call. = FALSE)
		  }

		  # schedule where(on) which job(job) will be executed at which time(at)	
		  for (i in 1:no.jobs){
		    if(ks.vector$ksack[i] != 0){
		      j =  ks.vector$ksack[i] 
		      scheduled = rbind(scheduled,list(job = i,on = j, at = occupied.time[j]))
		      occupied.time[j] = occupied.time[j] + xs.schedule.info$times[i]
		    }
		  }
		}else{
		  # schedule when only one job is within time Limit
		  scheduled = rbind(scheduled,list(job = 1, on = 1, at = 0))
		}	
		# reorder jobs to suit the load balancer
		scheduled = scheduled[order(scheduled$on),]
		load.balance.order = order(scheduled$at, decreasing = FALSE)
		scheduled = scheduled[load.balance.order,]
		xs = xs[scheduled$job]
		xs.trafo = xs.trafo[scheduled$job]
		xs.schedule.info = xs.schedule.info[scheduled$job,]
		extras = extras[scheduled$job]
		
		# Fill empty Nodes with Random Jobs# Fill empty Nodes with Random Jobs
		if (control$schedule.fill.random && (empty.slots = schedule.nodes - nrow(scheduled))>0) {
		  stuff = fillRandom(t.max = t.max, empty.slots = empty.slots, opt.state = opt.state)
		  used.slots = length(stuff[[1]])
		  if (used.slots>0){  
		    scheduled = rbind(scheduled, list(job = length(xs) + seq_along(1:used.slots), on = max(scheduled$on) + seq_along(1:used.slots), at = occupied.time[max(scheduled$on) + seq_along(1:used.slots)]))
		    xs = c(xs, stuff[[1]])
		    xs.trafo = c(xs.trafo, stuff[[2]])
		    extras = c(extras, stuff[[3]])
		  }
		}
		
		#put scheduling information into extras
		for (i in seq_row(scheduled)) {
			extras[[i]]$scheduled.job = scheduled$job[i]
			extras[[i]]$scheduled.on = scheduled$on[i]
			extras[[i]]$scheduled.at = scheduled$at[i]  
		  extras[[i]]$scheduled.priority = xs.schedule.info$priorities[i]
		}
	}
	evalScheduleParallelMap(wrapFun = wrapFun, xs = xs, xs.trafo = xs.trafo, xs.schedule.info = xs.schedule.info, extras = extras, opt.state = opt.state)
}
